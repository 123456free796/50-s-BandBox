<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml"
           xmlns:s="library://ns.adobe.com/flex/spark"
           xmlns="*"
           width="512"
           height="481"
           backgroundColor="0x000000"
           creationComplete="init()"
           addedToStage="onAddedToStage()">
	<mx:Script><![CDATA[
		import flash.display.*;
		import flash.events.*;
		import flash.geom.*;
		import flash.media.*;
		import flash.text.*;
		import flash.ui.*;
		import flash.utils.*;
		
		import mx.collections.ArrayCollection;
		
		public var partWidth: Number = 16;
		public const noteHeight: Number = 13;
		
		[Bindable]
		public var doc: Document;
		
		private var preview: Sprite;
		private var playhead: Sprite;
		private var mouseDown: Boolean = false;
		private var mouseOver: Boolean = false;
		private var mouseDragging: Boolean = false;
		private var length: int = 4;
		private var mouseXStart: Number = 0;
		private var mouseYStart: Number = 0;
		private var mouseXPrev: Number = 0;
		private var mouseYPrev: Number = 0;
		//private var precise: Boolean = false;
		//private var precisionX: Number = 0;
		private var dragChange: Change = null;
		private var cursor: Object = {};
		private var pattern: BarPattern;
		private var labels: Array;
		
		public function init():void {
			labels = [];
			for (var i: int = 0; i < Music.numNotes; i++) {
				var format: TextFormat = new TextFormat();
				format.align = TextFormatAlign.LEFT;
				format.bold = true;
				format.font = "Arial";
				format.size = 10;
				var text: TextField = new TextField();
				text.width = 30;
				text.x = 0;
				text.height = noteHeight;
				text.y = noteHeight * (Music.numNotes - i - 1);
				text.wordWrap = true;
				text.type = TextFieldType.DYNAMIC;
				text.textColor = 0xbbbbbb;
				text.selectable = false;
				text.mouseEnabled = false;
				text.defaultTextFormat = format;
				container.addChild(text);
				labels.push(text);
			}
			preview = new Sprite();
			container.addChild(preview);
			playhead = new Sprite();
			container.addChild(playhead);
			doc.watch(documentChanged);
			documentChanged();
			updateCursorStatus();
			render();
		}
		
		private function onAddedToStage(): void {
			addEventListener(Event.ENTER_FRAME, onEnterFrame);
			addEventListener(MouseEvent.MOUSE_DOWN, onMousePressed);
			stage.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMoved);
			stage.addEventListener(MouseEvent.MOUSE_UP, onMouseReleased);
			addEventListener(MouseEvent.ROLL_OVER, onMouseOver);
			addEventListener(MouseEvent.ROLL_OUT, onMouseOut);
			//stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);
			//stage.addEventListener(KeyboardEvent.KEY_UP, onKeyReleased);
		}
		
		private function updateCursorStatus(): void {
			cursor.prevTone = null;
			cursor.curTone  = null;
			cursor.nextTone = null;
			cursor.note     = 0;
			cursor.noteIndex= -1;
			cursor.curIndex = 0;
			cursor.start    = 0;
			cursor.end      = 0;
			cursor.part     = int(Math.max(0, Math.min(doc.beats * doc.parts - 1, mouseX / partWidth)));
			cursor.nearEnd  = false;
			
			var scale: Array = Music.scaleFlags[doc.scale];
			
			for each (var tone: Tone in pattern.tones) {
				if (tone.end <= cursor.part) {
					cursor.prevTone = tone;
					cursor.curIndex++;
				} else if (tone.start <= cursor.part && tone.end > cursor.part) {
					cursor.curTone = tone;
				} else if (tone.start > cursor.part) {
					cursor.nextTone = tone;
					break;
				}
			}
			
			var mouseNote: Number = Math.max(0, Math.min(Music.numNotes-1, Music.numNotes - (mouseY / noteHeight)));
			if (scale[int(mouseNote) % 12]) {
				cursor.note = int(mouseNote);
			} else {
				var topNote: int = int(mouseNote) + 1;
				var bottomNote: int = int(mouseNote) - 1;
				while (scale[topNote % 12] == false) {
					topNote++;
				}
				while (scale[(bottomNote) % 12] == false) {
					bottomNote--;
				}
				var topRange: Number = topNote;
				var bottomRange: Number = bottomNote + 1;
				if (topNote % 12 == 0 || topNote % 12 == 7) {
					topRange -= 0.5;
				}
				if (bottomNote % 12 == 0 || bottomNote % 12 == 7) {
					bottomRange += 0.5;
				}
				cursor.note = mouseNote - bottomRange > topRange - mouseNote ? topNote : bottomNote;
			}
			
			if (cursor.curTone != null) {
				cursor.start = cursor.curTone.start;
				cursor.end   = cursor.curTone.end;
				for (var i: int = 0; i < cursor.curTone.notes.length; i++) {
					if (cursor.curTone.notes[i] == int(mouseNote)) {
						cursor.noteIndex = i;
						cursor.note = int(mouseNote);
						break;
					} else if (cursor.curTone.notes[i] == cursor.note) {
						cursor.noteIndex = i;
					}
				}
				
				cursor.nearEnd = (mouseX / partWidth - cursor.start) / (cursor.end - cursor.start) > 0.5;
			} else {
				var quadBeats: int = cursor.part >> 2;
				var modLength: int = length % 4;
				if (modLength == 0) {
					cursor.start = quadBeats * 4;
				} else if (length >= 2) {
					var modBeat: int = cursor.part % 4;
					cursor.start = quadBeats * 4;
					if (modLength == 2) {
						if (modBeat >= 2) {
							cursor.start += 4 - modLength;
						}
					} else {
						if (modBeat == 3) {
							cursor.start += 4 - modLength;
						}
					}
				} else {
					cursor.start = cursor.part;
				}
				cursor.end = cursor.start + length;
				if (cursor.prevTone != null && cursor.start < cursor.prevTone.end) {
					cursor.start = cursor.prevTone.end;
				}
				if (cursor.nextTone != null && cursor.end   > cursor.nextTone.start) {
					cursor.end   = cursor.nextTone.start;
				}
				if (cursor.end > doc.beats * doc.parts) {
					cursor.end = doc.beats * doc.parts;
				}
			}
		}
		
		private function onEnterFrame(event: Event): void {
			playhead.graphics.clear();
			if (doc.synth.paused) return;
			if (doc.getBarPattern(doc.channel, doc.synth.bar) != pattern) return;
			playhead.graphics.lineStyle(4, 0xffffff);
			playhead.graphics.moveTo(doc.synth.playhead * width, 0);
			playhead.graphics.lineTo(doc.synth.playhead * width, height);
			playhead.graphics.lineStyle();
		}
		
		private function onMouseOver(event: Event): void {
			mouseOver = true;
		}
		
		private function onMouseOut(event: Event): void {
			mouseOver = false;
		}
		
		private function onMousePressed(event: Event): void {
			mouseDown = true;
			mouseXStart = mouseX;
			mouseYStart = mouseY;
			mouseXPrev = mouseX;
			mouseYPrev = mouseY;
			updateCursorStatus();
			updatePreview();
		}
		
		private function onMouseMoved(event: Event): void {
			var start: int;
			var end: int;
			if (mouseDown) {
				if (!mouseDragging) {
					var dx: Number = mouseX - mouseXStart;
					var dy: Number = mouseY - mouseYStart;
					if (Math.sqrt(dx * dx + dy * dy) > 5) {
						mouseDragging = true;
					}
				}
				
				if (mouseDragging) {
					if (dragChange != null) {
						dragChange.undo();
						dragChange = null;
					}
					
					var sequence: ChangeSequence = new ChangeSequence();
					
					if (cursor.curTone == null) {
						var currentPart: int = mouseX / partWidth;
						var backwards: Boolean;
						var directLength: int;
						if (currentPart < cursor.start) {
							backwards = true;
							directLength = cursor.start - currentPart;
						} else {
							backwards = false;
							directLength = currentPart - cursor.start + 1;
						}
						
						//if (backwards == mouseXPrev <
						length = 1;
						for each (var blessedLength: int in [1, 2, 3, 4, 6, 8, 12, 16, 24, 32]) {
							if (blessedLength == directLength) {
								length = blessedLength;
								break;
							}
							if (blessedLength < directLength) {
								length = blessedLength;
							}
							
							if (blessedLength > directLength) {
								if (length < directLength - 1) {
									length = blessedLength;
								}
								break;
							}
						}
						
						if (length < directLength) {
							// See if I can find a better match by snapping to an existing tone...
						}
						
						if (backwards) {
							end = cursor.start;
							start = end - length;
						} else {
							start = cursor.start;
							end = start + length;
						}
						if (start < 0) start = 0;
						if (end > doc.beats * doc.parts) end = doc.beats * doc.parts;
						
						sequence.append(new ChangeToneTruncate(pattern, start, end));
						var i: int = 0;
						while (i < pattern.tones.length) {
							var tone: Tone = pattern.tones[i];
							if (tone.start >= end) {
								break;
							}
							i++;
						}
						sequence.append(new ChangeToneAdded(pattern, new Tone(cursor.note, start, end), i));
					} else /*if (cursor.noteIndex == -1)*/ {
						var shift: int = Math.round((mouseX - mouseXStart) / partWidth);
						start = cursor.curTone.start + (cursor.nearEnd ? 0 : shift);
						end = cursor.curTone.end + (cursor.nearEnd ? shift : 0);
						if (start < 0) start = 0;
						if (end > doc.beats * doc.parts) end = doc.beats * doc.parts;
						
						if (start >= end) {
							sequence.append(new ChangeToneAdded(pattern, cursor.curTone, cursor.curIndex, true));
						} else {
							sequence.append(new ChangeToneTruncate(pattern, start, end, cursor.curTone));
							sequence.append(new ChangeToneLength(pattern, cursor.curTone, start, end));
						}
					//} else {
					}
					dragChange = sequence;
				}
				mouseXPrev = mouseX;
				mouseYPrev = mouseY;
			} else {
				updateCursorStatus();
				updatePreview();
			}
		}
		
		private function onMouseReleased(event: Event): void {
			if (mouseDragging) {
				if (dragChange != null) {
					doc.history.record(dragChange);
					dragChange = null;
				}
			} else if (mouseDown) {
				if (cursor.curTone == null) {
					doc.history.record(new ChangeToneAdded(pattern, new Tone(cursor.note, cursor.start, cursor.end), cursor.curIndex));
				} else {
					if (cursor.noteIndex == -1) {
						var sequence: ChangeSequence = new ChangeSequence();
						if (cursor.curTone.notes.length == 4) {
							sequence.append(new ChangeNoteAdded(pattern, cursor.curTone, cursor.curTone.notes[0], 0, true));
						}
						sequence.append(new ChangeNoteAdded(pattern, cursor.curTone, cursor.note, cursor.curTone.notes.length));
						doc.history.record(sequence);
					} else {
						if (cursor.curTone.notes.length == 1) {
							doc.history.record(new ChangeToneAdded(pattern, cursor.curTone, cursor.curIndex, true));
						} else {
							doc.history.record(new ChangeNoteAdded(pattern, cursor.curTone, cursor.note, cursor.curTone.notes.indexOf(cursor.note), true));
						}
					}
				}
			}
			
			mouseDown = false;
			mouseDragging = false;
			updateCursorStatus();
			render();
		}
		
		private function updatePreview(): void {
			preview.graphics.clear();
			if (!mouseOver || mouseDown) return;
			
			//if (cursor.noteIndex == -1) {
				preview.graphics.lineStyle(2, 0xffffff);
				if (cursor.curTone == null) {
					preview.graphics.drawRect(cursor.start * partWidth + 1, noteHeight * (Music.numNotes - cursor.note - 1) - 1, (cursor.end - cursor.start) * partWidth - 2, noteHeight + 2);
				} else {
					drawNote(preview.graphics, cursor.note, cursor.curTone.start, cursor.curTone.pins, noteHeight / 2 + 1);
				}
				preview.graphics.lineStyle();
			//}
		}
		
		private function documentChanged(): void {
			pattern = doc.getBarPattern(doc.channel, doc.bar);
			partWidth = width / (doc.beats * doc.parts);
			render();
		}
		
		private function render(): void {
			container.graphics.clear();
			container.graphics.beginFill(0);
			container.graphics.drawRect(0, 0, partWidth * doc.beats * doc.parts, noteHeight * Music.numNotes);
			container.graphics.endFill();
			
			for (var j: int = 0; j < Music.numNotes; j++) {
				if (Music.scaleFlags[doc.scale][j%12] == false) {
					labels[j].text = "";
					continue;
				} else {
					labels[j].text = Music.noteNames[(j + Music.keyTransposes[doc.key]) % 12];
				}
				var color: int = 0x444444;
				if (j%12 == 0) color = 0x886644;
				if (j%12 == 7) color = 0x446688;
				container.graphics.beginFill(color);
				for (var k: int = 0; k < doc.beats; k++) {
					container.graphics.drawRect(partWidth * k * doc.parts + 1, noteHeight * (Music.numNotes - j - 1) + 1, partWidth * doc.parts - 2, noteHeight - 2);
				}
				container.graphics.endFill();
			}
			
			var tone: Tone;
			var note: int;
			for (var channel: int = 2; channel >= 0; channel--) {
				if (channel == doc.channel) continue;
				for each (tone in doc.getBarPattern(channel, doc.bar).tones) {
					for each (note in tone.notes) {
						container.graphics.beginFill([0x66dd66, 0xcccc66, 0xdd8866][channel]);
						drawNote(container.graphics, note, tone.start, tone.pins, noteHeight / 2 - 4);
						container.graphics.endFill();
					}
				}
			}
			for each (tone in pattern.tones) {
				for each (note in tone.notes) {
					container.graphics.beginFill([0xccffcc, 0xffffcc, 0xffddcc][doc.channel]);
					drawNote(container.graphics, note, tone.start, tone.pins, noteHeight / 2 + 1);
					container.graphics.endFill();
				}
			}
			
			updatePreview();
		}
		
		private function drawNote(graphics: Graphics, note: int, start: int, pins: Array, radius: int): void {
			var prevPin: TonePin;
			var nextPin: TonePin = pins[0];
			
			for (var i: int = 1; i < pins.length; i++) {
				prevPin = nextPin;
				nextPin = pins[i];
				var leftSide:    Number = partWidth * (start + prevPin.time) + (i == 1 ? 1 : 0);
				var rightSide:   Number = partWidth * (start + nextPin.time) - (i == pins.length - 1 ? 1 : 0);
				var leftHeight:  Number = noteHeight * (Music.numNotes - (note + prevPin.interval) - 0.5);
				var rightHeight: Number = noteHeight * (Music.numNotes - (note + nextPin.interval) - 0.5);
				graphics.moveTo(leftSide,  leftHeight  - radius);
				graphics.lineTo(rightSide, rightHeight - radius);
				graphics.lineTo(rightSide, rightHeight + radius);
				graphics.lineTo(leftSide,  leftHeight  + radius);
				graphics.lineTo(leftSide,  leftHeight  - radius);
			}
		}
		
	]]></mx:Script>
	<mx:UIComponent id="container"/>
</mx:Canvas>
