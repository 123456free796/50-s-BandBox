<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml"
           xmlns:s="library://ns.adobe.com/flex/spark"
           xmlns="*"
           width="512"
           height="481"
           backgroundColor="0x000000"
           creationComplete="init()"
           addedToStage="onAddedToStage()">
	<mx:Script><![CDATA[
		import flash.display.*;
		import flash.events.*;
		import flash.geom.*;
		import flash.media.*;
		import flash.text.*;
		import flash.ui.*;
		import flash.utils.*;
		
		import mx.collections.ArrayCollection;
		
		public const beatWidth: Number = 16;
		public const noteHeight: Number = 13;
		
		[Bindable]
		public var doc: Document;
		
		private var preview: Sprite;
		private var playhead: Sprite;
		private var mouseDown: Boolean = false;
		private var mouseOver: Boolean = false;
		private var mouseDragging: Boolean = false;
		private var length: int = 4;
		private var mouseXStart: Number = 0;
		private var mouseYStart: Number = 0;
		private var mouseXPrev: Number = 0;
		private var mouseYPrev: Number = 0;
		//private var precise: Boolean = false;
		//private var precisionX: Number = 0;
		private var dragChange: Change = null;
		private var cursor: Object = {};
		private var pattern: BarPattern;
		
		public function init():void {
			preview = new Sprite();
			container.addChild(preview);
			playhead = new Sprite();
			container.addChild(playhead);
			pattern = doc.getBarPattern(doc.channel, doc.bar);
			updateCursorStatus();
			render();
			pattern.watch(render);
			doc.watch(documentChanged);
		}
		
		private function onAddedToStage(): void {
			addEventListener(Event.ENTER_FRAME, onEnterFrame);
			addEventListener(MouseEvent.MOUSE_DOWN, onMousePressed);
			stage.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMoved);
			stage.addEventListener(MouseEvent.MOUSE_UP, onMouseReleased);
			addEventListener(MouseEvent.ROLL_OVER, onMouseOver);
			addEventListener(MouseEvent.ROLL_OUT, onMouseOut);
			//stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);
			//stage.addEventListener(KeyboardEvent.KEY_UP, onKeyReleased);
		}
		
		private function updateCursorStatus(): void {
			cursor.prevTone = null;
			cursor.curTone  = null;
			cursor.nextTone = null;
			cursor.note     = 0;
			cursor.noteIndex= -1;
			cursor.curIndex = 0;
			cursor.start    = 0;
			cursor.end      = 0;
			cursor.beat     = int(Math.max(0, Math.min(Music.beatsPerBar - 1, mouseX / beatWidth)));
			cursor.nearEnd  = false;
			
			var scale: Array = Music.scaleFlags[doc.scale];
			
			for each (var tone: Tone in pattern.tones) {
				if (tone.end <= cursor.beat) {
					cursor.prevTone = tone;
					cursor.curIndex++;
				} else if (tone.start <= cursor.beat && tone.end > cursor.beat) {
					cursor.curTone = tone;
				} else if (tone.start > cursor.beat) {
					cursor.nextTone = tone;
					break;
				}
			}
			
			var mouseNote: Number = Math.max(0, Math.min(Music.numNotes, Music.numNotes - (mouseY / noteHeight)));
			if (scale[int(mouseNote) % 12]) {
				cursor.note = int(mouseNote);
			} else {
				var topNote: int = int(mouseNote) + 1;
				var bottomNote: int = int(mouseNote) - 1;
				while (scale[topNote % 12] == false) {
					topNote++;
				}
				while (scale[(bottomNote) % 12] == false) {
					bottomNote--;
				}
				var topRange: Number = topNote;
				var bottomRange: Number = bottomNote + 1;
				if (topNote % 12 == 0 || topNote % 12 == 7) {
					topRange -= 0.5;
				}
				if (bottomNote % 12 == 0 || bottomNote % 12 == 7) {
					bottomRange += 0.5;
				}
				cursor.note = mouseNote - bottomRange > topRange - mouseNote ? topNote : bottomNote;
			}
			
			if (cursor.curTone != null) {
				cursor.start = cursor.curTone.start;
				cursor.end   = cursor.curTone.end;
				for (var i: int = 0; i < cursor.curTone.notes.length; i++) {
					if (cursor.curTone.notes[i] == int(mouseNote)) {
						cursor.noteIndex = i;
						cursor.note = int(mouseNote);
						break;
					} else if (cursor.curTone.notes[i] == cursor.note) {
						cursor.noteIndex = i;
					}
				}
				
				cursor.nearEnd = (mouseX / beatWidth - cursor.start) / (cursor.end - cursor.start) > 0.5;
			} else {
				var quadBeats: int = cursor.beat >> 2;
				var modLength: int = length % 4;
				if (modLength == 0) {
					cursor.start = quadBeats * 4;
				} else if (length >= 2) {
					var modBeat: int = cursor.beat % 4;
					cursor.start = quadBeats * 4;
					if (modLength == 2) {
						if (modBeat >= 2) {
							cursor.start += 4 - modLength;
						}
					} else {
						if (modBeat == 3) {
							cursor.start += 4 - modLength;
						}
					}
				} else {
					cursor.start = cursor.beat;
				}
				cursor.end = cursor.start + length;
				if (cursor.prevTone != null && cursor.start < cursor.prevTone.end) {
					cursor.start = cursor.prevTone.end;
				}
				if (cursor.nextTone != null && cursor.end   > cursor.nextTone.start) {
					cursor.end   = cursor.nextTone.start;
				}
				if (cursor.end > Music.beatsPerBar) {
					cursor.end = Music.beatsPerBar;
				}
			}
		}
		
		private function onEnterFrame(event: Event): void {
			playhead.graphics.clear();
			if (doc.synth.paused) return;
			if (doc.getBarPattern(doc.channel, doc.synth.bar) != pattern) return;
			playhead.graphics.lineStyle(4, 0xffffff);
			playhead.graphics.moveTo(doc.synth.playhead * beatWidth, 0);
			playhead.graphics.lineTo(doc.synth.playhead * beatWidth, height);
			playhead.graphics.lineStyle();
		}
		
		private function onMouseOver(event: Event): void {
			mouseOver = true;
		}
		
		private function onMouseOut(event: Event): void {
			mouseOver = false;
		}
		
		private function onMousePressed(event: Event): void {
			mouseDown = true;
			mouseXStart = mouseX;
			mouseYStart = mouseY;
			mouseXPrev = mouseX;
			mouseYPrev = mouseY;
			updateCursorStatus();
			updatePreview();
		}
		
		private function onMouseMoved(event: Event): void {
			var start: int;
			var end: int;
			if (mouseDown) {
				if (!mouseDragging) {
					var dx: Number = mouseX - mouseXStart;
					var dy: Number = mouseY - mouseYStart;
					if (Math.sqrt(dx * dx + dy * dy) > 5) {
						mouseDragging = true;
					}
				}
				
				if (mouseDragging) {
					if (dragChange != null) {
						dragChange.undo();
						dragChange = null;
					}
					
					var sequence: ChangeSequence = new ChangeSequence();
					
					if (cursor.curTone == null) {
						var currentBeat: int = mouseX / beatWidth;
						var backwards: Boolean;
						var directLength: int;
						if (currentBeat < cursor.start) {
							backwards = true;
							directLength = cursor.start - currentBeat;
						} else {
							backwards = false;
							directLength = currentBeat - cursor.start + 1;
						}
						
						//if (backwards == mouseXPrev <
						length = 1;
						for each (var blessedLength: int in [1, 2, 3, 4, 6, 8, 12, 16, 24, 32]) {
							if (blessedLength == directLength) {
								length = blessedLength;
								break;
							}
							if (blessedLength < directLength) {
								length = blessedLength;
							}
							
							if (blessedLength > directLength) {
								if (length < directLength - 1) {
									length = blessedLength;
								}
								break;
							}
						}
						
						if (length < directLength) {
							// See if I can find a better match by snapping to an existing tone...
						}
						
						if (backwards) {
							end = cursor.start;
							start = end - length;
						} else {
							start = cursor.start;
							end = start + length;
						}
						if (start < 0) start = 0;
						if (end > Music.beatsPerBar) end = Music.beatsPerBar;
						
						sequence.append(new ChangeToneTruncate(pattern, start, end));
						var i: int = 0;
						while (i < pattern.tones.length) {
							var tone: Tone = pattern.tones[i];
							if (tone.start >= end) {
								break;
							}
							i++;
						}
						sequence.append(new ChangeToneAdded(pattern, new Tone(cursor.note, start, end), i));
					} else /*if (cursor.noteIndex == -1)*/ {
						var shift: int = Math.round((mouseX - mouseXStart) / beatWidth);
						start = cursor.curTone.start + (cursor.nearEnd ? 0 : shift);
						end = cursor.curTone.end + (cursor.nearEnd ? shift : 0);
						if (start < 0) start = 0;
						if (end > Music.beatsPerBar) end = Music.beatsPerBar;
						
						if (start >= end) {
							sequence.append(new ChangeToneAdded(pattern, cursor.curTone, cursor.curIndex, true));
						} else {
							sequence.append(new ChangeToneTruncate(pattern, start, end, cursor.curTone));
							sequence.append(new ChangeToneLength(pattern, cursor.curTone, start, end));
						}
					//} else {
					}
					dragChange = sequence;
				}
				mouseXPrev = mouseX;
				mouseYPrev = mouseY;
			} else {
				updateCursorStatus();
				updatePreview();
			}
		}
		
		private function onMouseReleased(event: Event): void {
			if (mouseDragging) {
				if (dragChange != null) {
					doc.history.record(dragChange);
					dragChange = null;
				}
			} else if (mouseDown) {
				if (cursor.curTone == null) {
					doc.history.record(new ChangeToneAdded(pattern, new Tone(cursor.note, cursor.start, cursor.end), cursor.curIndex));
				} else {
					if (cursor.noteIndex == -1) {
						var sequence: ChangeSequence = new ChangeSequence();
						if (cursor.curTone.notes.length == 4) {
							sequence.append(new ChangeNoteAdded(pattern, cursor.curTone, cursor.curTone.notes[0], 0, true));
						}
						sequence.append(new ChangeNoteAdded(pattern, cursor.curTone, cursor.note, cursor.curTone.notes.length));
						doc.history.record(sequence);
					} else {
						if (cursor.curTone.notes.length == 1) {
							doc.history.record(new ChangeToneAdded(pattern, cursor.curTone, cursor.curIndex, true));
						} else {
							doc.history.record(new ChangeNoteAdded(pattern, cursor.curTone, cursor.note, cursor.curTone.notes.indexOf(cursor.note), true));
						}
					}
				}
			}
			
			mouseDown = false;
			mouseDragging = false;
			updateCursorStatus();
			render();
		}
		
		private function updatePreview(): void {
			preview.graphics.clear();
			if (!mouseOver || mouseDown) return;
			
			if (cursor.noteIndex == -1) {
				preview.graphics.lineStyle(2, 0xffffff);
				if (cursor.curTone == null) {
					preview.graphics.drawRect(cursor.start * beatWidth + 1, noteHeight * (Music.numNotes - cursor.note - 1) - 1, (cursor.end - cursor.start) * beatWidth - 2, noteHeight + 2);
				} else {
					drawNote(preview.graphics, cursor.note, cursor.curTone.start, cursor.curTone.pins);
				}
				preview.graphics.lineStyle();
			}
		}
		
		private function documentChanged(): void {
			pattern.unwatch(render);
			pattern = doc.getBarPattern(doc.channel, doc.bar);
			pattern.watch(render);
			
			render();
		}
		
		private function render(): void {
			container.graphics.clear();
			container.graphics.beginFill(0);
			container.graphics.drawRect(0, 0, beatWidth * Music.beatsPerBar, noteHeight * Music.numNotes);
			container.graphics.endFill();
			
			for (var j: int = 0; j < Music.numNotes; j++) {
				if (Music.scaleFlags[doc.scale][j%12] == false) continue;
				var color: int = 0x444444;
				if (j%12 == 0) color = 0x886644;
				if (j%12 == 7) color = 0x446688;
				container.graphics.beginFill(color);
				for (var k: int = 0; k < Music.beatsPerBar / 4; k++) {
					container.graphics.drawRect(beatWidth * k * 4 + 1, noteHeight * (Music.numNotes - j - 1) + 1, beatWidth * 4 - 2, noteHeight - 2);
				}
				container.graphics.endFill();
			}
			
			for each (var tone: Tone in pattern.tones) {
				for each (var note: int in tone.notes) {
					container.graphics.beginFill(0xffffff);
					drawNote(container.graphics, note, tone.start, tone.pins);
					container.graphics.endFill();
				}
			}
			
			updatePreview();
		}
		
		private function drawNote(graphics: Graphics, note: int, start: int, pins: Array): void {
			var prevPin: TonePin;
			var nextPin: TonePin = pins[0];
			
			for (var i: int = 1; i < pins.length; i++) {
				prevPin = nextPin;
				nextPin = pins[i];
				var leftSide: Number = beatWidth * (start + prevPin.time) + (i == 1 ? 1 : 0);
				var rightSide: Number = beatWidth * (start + nextPin.time) - (i == pins.length - 1 ? 1 : 0);
				graphics.moveTo(
					leftSide,
					noteHeight * (Music.numNotes - (note + prevPin.interval) - 1) - 1
				);
				graphics.lineTo(
					rightSide,
					noteHeight * (Music.numNotes - (note + nextPin.interval) - 1) - 1
				);
				graphics.lineTo(
					rightSide,
					noteHeight * (Music.numNotes - (note + nextPin.interval)) + 1
				);
				graphics.lineTo(
					leftSide,
					noteHeight * (Music.numNotes - (note + prevPin.interval)) + 1
				);
				graphics.lineTo(
					leftSide,
					noteHeight * (Music.numNotes - (note + prevPin.interval) - 1) - 1
				);
			}
		}
		
	]]></mx:Script>
	<mx:UIComponent id="container"/>
</mx:Canvas>
