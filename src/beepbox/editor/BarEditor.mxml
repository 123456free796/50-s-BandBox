<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright (C) 2012 John Nesky

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
-->

<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml"
           xmlns:s="library://ns.adobe.com/flex/spark"
           xmlns="*"
           height="481"
           backgroundColor="0x000000"
           creationComplete="init()"
           addedToStage="onAddedToStage()">
	<mx:Script><![CDATA[
		import flash.display.*;
		import flash.events.*;
		import flash.geom.*;
		import flash.media.*;
		import flash.text.*;
		import flash.ui.*;
		import flash.utils.*;
		
		import mx.collections.ArrayCollection;
		
		import beepbox.synth.*;
		
		public var partWidth: Number;
		public var noteHeight: Number;
		public var noteCount: int;
		
		[Bindable]
		public var doc: Document;
		
		private var preview: Sprite;
		private var playhead: Sprite;
		private var mouseDown: Boolean = false;
		private var mouseOver: Boolean = false;
		private var mouseDragging: Boolean = false;
		private var mouseVertical: Boolean = false;
		private var defaultLength: int = 4;
		private var defaultVolume: int = 3;
		private var mouseXStart: Number = 0;
		private var mouseYStart: Number = 0;
		private var mouseXPrev: Number = 0;
		private var mouseYPrev: Number = 0;
		//private var precise: Boolean = false;
		//private var precisionX: Number = 0;
		private var dragChange: Change = null;
		private var cursor: BarCursorStatus = new BarCursorStatus();
		private var pattern: BarPattern;
		private var playheadX: Number = 0.0;
		
		public function init():void {
			preview = new Sprite();
			container.addChild(preview);
			playhead = new Sprite();
			container.addChild(playhead);
			doc.watch(documentChanged);
			documentChanged();
			updateCursorStatus();
			updatePreview();
		}
		
		private function onAddedToStage(): void {
			addEventListener(Event.ENTER_FRAME, onEnterFrame);
			addEventListener(MouseEvent.MOUSE_DOWN, onMousePressed);
			stage.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMoved);
			stage.addEventListener(MouseEvent.MOUSE_UP, onMouseReleased);
			addEventListener(MouseEvent.ROLL_OVER, onMouseOver);
			addEventListener(MouseEvent.ROLL_OUT, onMouseOut);
			//stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);
			//stage.addEventListener(KeyboardEvent.KEY_UP, onKeyReleased);
		}
		
		private function updateCursorStatus(): void {
			cursor = new BarCursorStatus();
			cursor.part    = int(Math.max(0, Math.min(doc.song.beats * doc.song.parts - 1, mouseX / partWidth)));
			
			var scale: Array = Music.scaleFlags[doc.song.scale];
			var i: int;
			
			for each (var tone: Tone in pattern.tones) {
				if (tone.end <= cursor.part) {
					cursor.prevTone = tone;
					cursor.curIndex++;
				} else if (tone.start <= cursor.part && tone.end > cursor.part) {
					cursor.curTone = tone;
				} else if (tone.start > cursor.part) {
					cursor.nextTone = tone;
					break;
				}
			}
			
			var mouseNote: Number = Math.max(0, Math.min(noteCount-1, noteCount - (mouseY / noteHeight)));
			if (scale[int(mouseNote) % 12] || doc.channel == 3) {
				cursor.note = int(mouseNote);
			} else {
				var topNote: int = int(mouseNote) + 1;
				var bottomNote: int = int(mouseNote) - 1;
				while (scale[topNote % 12] == false) {
					topNote++;
				}
				while (scale[(bottomNote) % 12] == false) {
					bottomNote--;
				}
				var topRange: Number = topNote;
				var bottomRange: Number = bottomNote + 1;
				if (topNote % 12 == 0 || topNote % 12 == 7) {
					topRange -= 0.5;
				}
				if (bottomNote % 12 == 0 || bottomNote % 12 == 7) {
					bottomRange += 0.5;
				}
				cursor.note = mouseNote - bottomRange > topRange - mouseNote ? topNote : bottomNote;
			}
			
			if (cursor.curTone != null) {
				cursor.start = cursor.curTone.start;
				cursor.end   = cursor.curTone.end;
				
				for (i = 0; i < cursor.curTone.notes.length; i++) {
					if (cursor.curTone.notes[i] == int(mouseNote)) {
						cursor.noteIndex = i;
						cursor.note = int(mouseNote);
						break;
					} else if (cursor.curTone.notes[i] == cursor.note) {
						cursor.noteIndex = i;
					}
				}
				
				cursor.tonePart = Math.round(mouseX / partWidth) - cursor.start;
				var shortestDistance: int = int.MAX_VALUE;
				for (i = 0; i < cursor.curTone.pins.length; i++) {
					
				}
				
				cursor.nearEnd = (mouseX / partWidth - cursor.start) / (cursor.end - cursor.start) > 0.5;
			} else {
				var quadBeats: int = cursor.part / doc.song.parts;
				var modLength: int = defaultLength % doc.song.parts;
				var modMouse: int = cursor.part % doc.song.parts;
				if (defaultLength == 1) {
					cursor.start = cursor.part;
				} else if (modLength == 0) {
					cursor.start = quadBeats * doc.song.parts;
					if (doc.song.parts >> 1 == doc.song.parts / 2 && modMouse > doc.song.parts / 2 && defaultLength == doc.song.parts) {
						cursor.start += doc.song.parts / 2;
					}
				} else {
					cursor.start = quadBeats * doc.song.parts;
					if (modLength == doc.song.parts / 2) {
						if (modMouse >= doc.song.parts / 2) {
							cursor.start += doc.song.parts - modLength;
						}
					} else {
						if (modMouse > doc.song.parts / 2) {
							cursor.start += doc.song.parts - modLength;
						}
					}
				}
				cursor.end = cursor.start + defaultLength;
				var forceStart: int = 0;
				var forceEnd: int = doc.song.beats * doc.song.parts;
				if (cursor.prevTone != null) {
					forceStart = cursor.prevTone.end;
				}
				if (cursor.nextTone != null) {
					forceEnd   = cursor.nextTone.start;
				}
				if (cursor.start < forceStart) {
					cursor.start = forceStart;
					cursor.end = cursor.start + defaultLength;
					if (cursor.end > forceEnd) {
						cursor.end = forceEnd;
					}
				} else if (cursor.end > forceEnd) {
					cursor.end = forceEnd;
					cursor.start = cursor.end - defaultLength;
					if (cursor.start < forceStart) {
						cursor.start = forceStart;
					}
				}
			}
		}
		
		private function onEnterFrame(event: Event): void {
			playhead.graphics.clear();
			if (!doc.synth.playing) return;
			if (doc.song.getBarPattern(doc.channel, int(doc.synth.playhead)) != pattern) return;
			var modPlayhead: Number = doc.synth.playhead - int(doc.synth.playhead);
			if (Math.abs(modPlayhead - playheadX) > 0.1) {
				playheadX = modPlayhead;
			} else {
				playheadX += (modPlayhead - playheadX) * 0.2;
			}
			playhead.graphics.lineStyle(4, 0xffffff);
			playhead.graphics.moveTo(playheadX * width, 0);
			playhead.graphics.lineTo(playheadX * width, height);
			playhead.graphics.lineStyle();
		}
		
		private function onMouseOver(event: Event): void {
			mouseOver = true;
		}
		
		private function onMouseOut(event: Event): void {
			mouseOver = false;
		}
		
		private function onMousePressed(event: Event): void {
			mouseDown = true;
			mouseXStart = mouseX;
			mouseYStart = mouseY;
			mouseXPrev = mouseX;
			mouseYPrev = mouseY;
			updateCursorStatus();
			updatePreview();
		}
		
		private function onMouseMoved(event: Event): void {
			var start: int;
			var end: int;
			var i: int = 0;
			if (mouseDown) {
				if (!mouseDragging) {
					var dx: Number = mouseX - mouseXStart;
					var dy: Number = mouseY - mouseYStart;
					if (Math.sqrt(dx * dx + dy * dy) > 5) {
						mouseDragging = true;
						mouseVertical = Math.abs(dx) < Math.abs(dy);
					}
				}
				
				if (mouseDragging) {
					if (dragChange != null) {
						dragChange.undo();
						dragChange = null;
					}
					
					var sequence: ChangeSequence = new ChangeSequence();
					
					if (cursor.curTone == null) {
						var currentPart: int = mouseX / partWidth;
						var backwards: Boolean;
						var directLength: int;
						if (currentPart < cursor.start) {
							backwards = true;
							directLength = cursor.start - currentPart;
						} else {
							backwards = false;
							directLength = currentPart - cursor.start + 1;
						}
						
						defaultLength = 1;
						//for each (var blessedLength: int in [1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 36, ]) {
						for (i = 0; i <= doc.song.beats * doc.song.parts; i++) {
							if (i >= 5 &&
							    i % doc.song.parts != 0 &&
							    i != doc.song.parts * 3.0 / 2.0 &&
							    i != doc.song.parts * 4.0 / 3.0 &&
							    i != doc.song.parts * 5.0 / 3.0)
							{
								continue;
							}
							var blessedLength: int = i;
							if (blessedLength == directLength) {
								defaultLength = blessedLength;
								break;
							}
							if (blessedLength < directLength) {
								defaultLength = blessedLength;
							}
							
							if (blessedLength > directLength) {
								if (defaultLength < directLength - 1) {
									defaultLength = blessedLength;
								}
								break;
							}
						}
						
						if (defaultLength < directLength) {
							// See if I can find a better match by snapping to an existing tone...
						}
						
						if (backwards) {
							end = cursor.start;
							start = end - defaultLength;
						} else {
							start = cursor.start;
							end = start + defaultLength;
						}
						if (start < 0) start = 0;
						if (end > doc.song.beats * doc.song.parts) end = doc.song.beats * doc.song.parts;
						
						defaultVolume = int((mouseYStart - mouseY) / 30.0) + 3;
						if (defaultVolume < 0) defaultVolume = 0;
						if (defaultVolume > 3) defaultVolume = 3;
						
						sequence.append(new ChangeToneTruncate(doc, pattern, start, end));
						i = 0;
						while (i < pattern.tones.length) {
							var tone: Tone = pattern.tones[i];
							if (tone.start >= end) {
								break;
							}
							i++;
						}
						sequence.append(new ChangeToneAdded(doc, pattern, new Tone(cursor.note, start, end, defaultVolume, doc.channel == 3), i));
					} else if (!mouseVertical) {
						var shift: int = Math.round((mouseX - mouseXStart) / partWidth);
						start = cursor.curTone.start + (cursor.nearEnd ? 0 : shift);
						end = cursor.curTone.end + (cursor.nearEnd ? shift : 0);
						if (start < 0) start = 0;
						if (end > doc.song.beats * doc.song.parts) end = doc.song.beats * doc.song.parts;
						
						if (start >= end) {
							sequence.append(new ChangeToneAdded(doc, pattern, cursor.curTone, cursor.curIndex, true));
						} else {
							sequence.append(new ChangeToneTruncate(doc, pattern, start, end, cursor.curTone));
							sequence.append(new ChangeToneLength(doc, pattern, cursor.curTone, start, end));
							defaultLength = end - start;
						}
					} else if (cursor.noteIndex == -1) {
						// todo: pitch bend
					} else {
						
						
						//sequence.append(new ChangePinAdded(doc, pattern, cursor.curTone, pin, cursor.curIndex));
					}
					dragChange = sequence;
				}
				mouseXPrev = mouseX;
				mouseYPrev = mouseY;
			} else {
				updateCursorStatus();
				updatePreview();
			}
		}
		
		private function onMouseReleased(event: Event): void {
			if (mouseDragging) {
				if (dragChange != null) {
					doc.history.record(dragChange);
					dragChange = null;
				}
			} else if (mouseDown) {
				if (cursor.curTone == null) {
					doc.history.record(new ChangeToneAdded(doc, pattern, new Tone(cursor.note, cursor.start, cursor.end, defaultVolume, doc.channel == 3), cursor.curIndex));
				} else {
					if (cursor.noteIndex == -1) {
						var sequence: ChangeSequence = new ChangeSequence();
						if (cursor.curTone.notes.length == 4) {
							sequence.append(new ChangeNoteAdded(doc, pattern, cursor.curTone, cursor.curTone.notes[0], 0, true));
						}
						sequence.append(new ChangeNoteAdded(doc, pattern, cursor.curTone, cursor.note, cursor.curTone.notes.length));
						doc.history.record(sequence);
					} else {
						if (cursor.curTone.notes.length == 1) {
							doc.history.record(new ChangeToneAdded(doc, pattern, cursor.curTone, cursor.curIndex, true));
						} else {
							doc.history.record(new ChangeNoteAdded(doc, pattern, cursor.curTone, cursor.note, cursor.curTone.notes.indexOf(cursor.note), true));
						}
					}
				}
			}
			
			mouseDown = false;
			mouseDragging = false;
			updateCursorStatus();
			render();
		}
		
		private function updatePreview(): void {
			preview.graphics.clear();
			if (!mouseOver || mouseDown) return;
			
			//if (cursor.noteIndex == -1) {
				preview.graphics.lineStyle(2, 0xffffff);
				if (cursor.curTone == null) {
					preview.graphics.drawRect(cursor.start * partWidth + 1, noteHeight * (noteCount - cursor.note - 1) - 1, (cursor.end - cursor.start) * partWidth - 2, noteHeight + 2);
				} else {
					drawNote(preview.graphics, cursor.note, cursor.curTone.start, cursor.curTone.pins, noteHeight / 2 + 1, false);
				}
				preview.graphics.lineStyle();
			//}
		}
		
		private function documentChanged(): void {
			pattern = doc.song.getBarPattern(doc.channel, doc.bar);
			partWidth = (doc.showLetters ? 480 : 512) / (doc.song.beats * doc.song.parts);
			noteHeight = doc.channel == 3 ? 43 : 13;
			noteCount = doc.channel == 3 ? Music.drumCount : Music.noteCount;
			render();
		}
		
		private function render(): void {
			container.graphics.clear();
			container.graphics.beginFill(0);
			container.graphics.drawRect(0, 0, partWidth * doc.song.beats * doc.song.parts, noteHeight * noteCount);
			container.graphics.endFill();
			
			for (var j: int = 0; j < noteCount; j++) {
				if (doc.channel != 3 && Music.scaleFlags[doc.song.scale][j%12] == false) {
					continue;
				}
				var color: int = 0x444444;
				if (doc.channel != 3) {
					if (j%12 == 0) color = 0x886644;
					if (j%12 == 7 && doc.showFifth) color = 0x446688;
				}
				container.graphics.beginFill(color);
				for (var k: int = 0; k < doc.song.beats; k++) {
					container.graphics.drawRect(partWidth * k * doc.song.parts + 1, noteHeight * (noteCount - j - 1) + 1, partWidth * doc.song.parts - 2, noteHeight - 2);
				}
				container.graphics.endFill();
			}
			
			var tone: Tone;
			var note: int;
			if (doc.channel != 3 && doc.showChannels) {
				for (var channel: int = 2; channel >= 0; channel--) {
					if (channel == doc.channel) continue;
					for each (tone in doc.song.getBarPattern(channel, doc.bar).tones) {
						for each (note in tone.notes) {
							container.graphics.beginFill([0x66dd66, 0xcccc66, 0xdd8866, 0xaaaaaa][channel]);
							drawNote(container.graphics, note, tone.start, tone.pins, noteHeight / 2 - 4, false);
							container.graphics.endFill();
						}
					}
				}
			}
			for each (tone in pattern.tones) {
				for each (note in tone.notes) {
					container.graphics.beginFill([0x66dd66, 0xcccc66, 0xdd8866, 0xaaaaaa][doc.channel]);
					drawNote(container.graphics, note, tone.start, tone.pins, noteHeight / 2 + 1, false);
					container.graphics.endFill();
					container.graphics.beginFill([0xccffcc, 0xffffcc, 0xffddcc, 0xeeeeee][doc.channel]);
					drawNote(container.graphics, note, tone.start, tone.pins, noteHeight / 2 + 1, true);
					container.graphics.endFill();
				}
			}
			
			updatePreview();
		}
		
		private function drawNote(graphics: Graphics, note: int, start: int, pins: Array, radius: int, showVolume: Boolean): void {
			var prevPin: TonePin;
			var nextPin: TonePin = pins[0];
			
			for (var i: int = 1; i < pins.length; i++) {
				prevPin = nextPin;
				nextPin = pins[i];
				var leftSide:    Number = partWidth * (start + prevPin.time) + (i == 1 ? 1 : 0);
				var rightSide:   Number = partWidth * (start + nextPin.time) - (i == pins.length - 1 ? 1 : 0);
				var leftHeight:  Number = noteHeight * (noteCount - (note + prevPin.interval) - 0.5);
				var rightHeight: Number = noteHeight * (noteCount - (note + nextPin.interval) - 0.5);
				var leftVolume:  Number = showVolume ? prevPin.volume / 3.0 : 1.0;
				var rightVolume: Number = showVolume ? nextPin.volume / 3.0 : 1.0;
				graphics.moveTo(leftSide,  leftHeight  - radius * leftVolume);
				graphics.lineTo(rightSide, rightHeight - radius * rightVolume);
				graphics.lineTo(rightSide, rightHeight + radius * rightVolume);
				graphics.lineTo(leftSide,  leftHeight  + radius * leftVolume);
				graphics.lineTo(leftSide,  leftHeight  - radius * leftVolume);
			}
		}
		
	]]></mx:Script>
	<mx:UIComponent id="container"/>
</mx:Canvas>
