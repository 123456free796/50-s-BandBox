<?xml version="1.0" encoding="utf-8"?>
<s:BorderContainer xmlns:fx="http://ns.adobe.com/mxml/2009" 
           xmlns:s="library://ns.adobe.com/flex/spark"
           xmlns="beepbox.editor.*"
           width="675"
           height="645"
           backgroundColor="0x000000"
           borderVisible="false"
           borderWeight="0"
           creationComplete="init()"
           addedToStage="onAddedToStage()">
	<fx:Script><![CDATA[
		import flash.display.*;
		import flash.events.*;
		import flash.geom.*;
		import flash.media.*;
		import flash.text.*;
		import flash.ui.*;
		import flash.utils.*;
		
		import mx.collections.ArrayCollection;
		
		import beepbox.synth.*;
		
		[Bindable]
		public var doc: Document;
		
		[Bindable]
		private var scaleNames: ArrayCollection;
		[Bindable]
		private var keyNames: ArrayCollection;
		[Bindable]
		private var tempoNames: ArrayCollection;
		[Bindable]
		private var beatNames: ArrayCollection;
		[Bindable]
		private var partNames: ArrayCollection;
		[Bindable]
		private var waveNames: ArrayCollection;
		[Bindable]
		private var filterNames: ArrayCollection;
		[Bindable]
		private var filterDecayNames: ArrayCollection;
		
		public function init():void {
			scaleNames = new ArrayCollection(Music.scaleNames);
			keyNames = new ArrayCollection(Music.keyNames);
			tempoNames = new ArrayCollection(Music.tempoNames);
			beatNames = new ArrayCollection(Music.beatNames);
			partNames = new ArrayCollection(Music.partNames);
			waveNames = new ArrayCollection(Music.waveNames);
			filterNames = new ArrayCollection(Music.filterNames);
			filterDecayNames = new ArrayCollection(Music.filterDecayNames);
			doc.watch(onUpdated);
			onUpdated();
			
			editorBox.addEventListener(MouseEvent.MOUSE_DOWN, refocusStage);
		}
		
		private function refocusStage(event: Event): void {
			stage.focus = stage;
		}
		
		private function onUpdated(): void {
			scaleDropDown.selectedIndex = doc.song.scale;
			keyDropDown.selectedIndex = doc.song.key;
			tempoDropDown.selectedIndex = doc.song.tempo;
			beatDropDown.selectedIndex = Music.beatCounts.indexOf(doc.song.beats);
			partDropDown.selectedIndex = Music.partCounts.indexOf(doc.song.parts);
			showLetters.selected = doc.showLetters;
			showFifth.selected = doc.showFifth;
			showChannels.selected = doc.showChannels;
			if (doc.channel == 3) {
				channelSettings.visible = false;
			} else {
				channelSettings.visible = true;
				waveDropDown.selectedIndex = doc.song.channelWaves[doc.channel];
				filterDropDown.selectedIndex = doc.song.channelFilters[doc.channel];
				filterDecayDropDown.selectedIndex = doc.song.channelFilterDecays[doc.channel];
			}
			currentState = doc.showLetters ? "showPiano" : "hidePiano";
			barEditor.width = doc.showLetters ? 480 : 512;
			undoButton.enabled = doc.history.canUndo();
			redoButton.enabled = doc.history.canRedo();
		}
		
		private function onAddedToStage(): void {
			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);
			stage.addEventListener(KeyboardEvent.KEY_UP, onKeyReleased);
		}
		
		private function onKeyPressed(event: KeyboardEvent): void {
			//if (event.ctrlKey)
			switch (event.keyCode) {
				case 32: // space
					stage.focus = stage;
					togglePlay();
					break;
				case 90: // z
					if (event.shiftKey) {
						doc.history.redo();
					} else {
						doc.history.undo();
					}
					break;
				case 89: // y
					doc.history.redo();
					break;
				case 219: // left brace
					doc.synth.prevBar();
					break;
				case 221: // right brace
					doc.synth.nextBar();
					break;
			}
		}
		
		private function onKeyReleased(event: KeyboardEvent): void {
		}
		
		private function togglePlay(): void {
			if (doc.synth.playing) {
				doc.synth.pause();
				doc.synth.snapToBar();
				playButton.label = "Resume Playback";
			} else {
				doc.synth.play();
				playButton.label = "Pause Playback";
			}
		}
		
		private function cleanSlate(): void {
			doc.history.record(new ChangeSong(doc, null));
		}
		
		private function export(): void {
			var wasPlaying: Boolean = doc.synth.playing;
			if (wasPlaying) togglePlay();
			
			var sampleFrames: int = doc.synth.totalSamples;
			var recordedSamples: ByteArray = new ByteArray();
			var timer: int = getTimer();
			new Synth(doc.song).synthesize(recordedSamples, sampleFrames, false);
			//trace("export timer", getTimer() - timer);
			
			var srcChannelCount: int = 2;
			var wavChannelCount: int = 1;
			var sampleRate: int = 44100;
			var bytesPerSample: int = 2;
			var bitsPerSample: int = 8 * bytesPerSample;
			var sampleCount: int = wavChannelCount * sampleFrames;

			var data: ByteArray = new ByteArray();
			data.endian = Endian.LITTLE_ENDIAN;
			data.writeUTFBytes("RIFF");
			data.writeInt(36 + sampleCount * bytesPerSample); // size of remaining file
			data.writeUTFBytes("WAVEfmt ");
			data.writeInt(0x00000010); // size of following header
			data.writeShort(0x0001); // not compressed
			data.writeShort(wavChannelCount); // channel count
			data.writeInt(sampleRate); // sample rate
			data.writeInt(sampleRate * bytesPerSample * wavChannelCount); // bytes per second
			data.writeShort(bytesPerSample); // sample rate
			data.writeShort(bitsPerSample); // sample rate
			data.writeUTFBytes("data");
			data.writeInt(sampleCount * bytesPerSample);
			
			var stride: int;
			var repeat: int;
			if (srcChannelCount == wavChannelCount) {
				stride = 1;
				repeat = 1;
			} else {
				stride = srcChannelCount;
				repeat = wavChannelCount;
			}
			
			var i: int;
			var j: int;
			var k: int;
			var val: int;
			recordedSamples.position = 0;
			if (bytesPerSample > 1) {
				// usually samples are signed. 
				for (i = 0; i < sampleFrames; i++) {
					for (j = 0; j < stride; j++) {
						val = recordedSamples.readFloat() * ((1 << (bitsPerSample - 1)) - 1);
					}
					for (k = 0; k < repeat; k++) {
						if (bytesPerSample == 2) {
							data.writeShort(val);
						} else if (bytesPerSample == 4) {
							data.writeInt(val);
						} else {
							throw new Error("unsupported sample size");
						}
					}
				}
			} else {
				// 8 bit samples are a special case: they are unsigned.
				for (i = 0; i < sampleFrames; i++) {
					for (j = 0; j < stride; j++) {
						val = recordedSamples.readFloat() * 127 + 128;
					}
					for (k = 0; k < repeat; k++) {
						data.writeByte(val > 255 ? 255 : (val < 0 ? 0 : val));
					}
				}
			}
			
			new FileReference().save(data, "song.wav");
			
			if (wasPlaying) togglePlay();
		}
		
		private function onSetScale(): void {
			var scale: int = scaleDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeScale) doc.history.undo();
			doc.history.record(new ChangeScale(doc, scale));
		}
		
		private function onSetKey(): void {
			var key: int = keyDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeKey) doc.history.undo();
			doc.history.record(new ChangeKey(doc, key));
		}
		
		private function onSetTempo(): void {
			var tempo: int = tempoDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeTempo) doc.history.undo();
			doc.history.record(new ChangeTempo(doc, tempo));
		}
		
		private function onSetBeats(): void {
			var beats: int = Music.beatCounts[beatDropDown.selectedIndex];
			//if (doc.history.getRecentChange() is ChangeBeats) doc.history.undo();
			doc.history.record(new ChangeBeats(doc, beats));
		}
		
		private function onSetParts(): void {
			var parts: int = Music.partCounts[partDropDown.selectedIndex];
			//if (doc.history.getRecentChange() is ChangeParts) doc.history.undo();
			doc.history.record(new ChangeParts(doc, parts));
		}
		
		private function onSetWave(): void {
			var wave: int = waveDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeWave) doc.history.undo();
			doc.history.record(new ChangeWave(doc, wave));
		}
		
		private function onSetFilter(): void {
			var filter: int = filterDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeFilter) doc.history.undo();
			doc.history.record(new ChangeFilter(doc, filter));
		}
		
		private function onSetFilterDecay(): void {
			var filterDecay: int = filterDecayDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeFilterDecay) doc.history.undo();
			doc.history.record(new ChangeFilterDecay(doc, filterDecay));
		}
		
		private function toggleLetters(): void {
			doc.showLetters = !doc.showLetters;
			doc.changed();
			doc.savePreferences();
		}
		
		private function toggleFifth(): void {
			doc.showFifth = !doc.showFifth;
			doc.changed();
			doc.savePreferences();
		}
		
		private function toggleChannels(): void {
			doc.showChannels = !doc.showChannels;
			doc.changed();
			doc.savePreferences();
		}
	]]></fx:Script>
	
	<s:states>
		<s:State name="hidePiano"/>
		<s:State name="showPiano"/>
	</s:states>
	
	<s:HGroup width="100%" height="100%">
		<s:VGroup width="512" id="editorBox">
			<s:HGroup width="512" height="481" gap="0">
				<Piano id="piano" doc="{doc}" includeIn="showPiano"/>
				<BarEditor id="barEditor" doc="{doc}"/>
			</s:HGroup>
			<TrackEditor doc="{doc}"/>
			<LoopEditor doc="{doc}"/>
		</s:VGroup>
		<s:VGroup width="100%" horizontalAlign="right" height="100%">
			<s:VGroup id="songSettings" height="481" width="100%">
				<s:Button id="playButton" label="Pause Playback" click="togglePlay(); stage.focus = stage" width="100%"/>
				<s:Button id="cleanButton" label="Clean slate" click="cleanSlate(); stage.focus = stage" width="100%"/>
				<s:Button id="exportButton" label="Save as .wav file" click="export(); stage.focus = stage" width="100%"/>
				<s:HGroup width="100%" verticalAlign="middle">
					<s:Button id="undoButton" label="Undo" enabled="false" click="doc.history.undo(); stage.focus = stage" width="50%"/>
					<s:Button id="redoButton" label="Redo" enabled="false" click="doc.history.redo(); stage.focus = stage" width="50%"/>
				</s:HGroup>
				<s:Spacer height="5"/>
				<s:Label text="Preferences:" color="0xffffff"/>
				<s:CheckBox id="showLetters" label="Show Piano" color="0xbbbbbb" change="toggleLetters(); stage.focus = stage"/>
				<s:CheckBox id="showFifth" label="Highlight 'Fifth' Notes" color="0xbbbbbb" change="toggleFifth(); stage.focus = stage"/>
				<s:CheckBox id="showChannels" label="Show All Channels" color="0xbbbbbb" change="toggleChannels(); stage.focus = stage"/>
				<s:Spacer height="5"/>
				<s:Label text="Song Settings:" color="0xffffff"/>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Scale:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="scaleDropDown" dataProvider="{scaleNames}" width="85" change="onSetScale()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{scaleNames.length}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Key:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="keyDropDown" dataProvider="{keyNames}" width="55" change="onSetKey()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{keyNames.length}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Tempo:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="tempoDropDown" dataProvider="{tempoNames}" width="75" change="onSetTempo()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{tempoNames.length}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Beats per bar:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="beatDropDown" dataProvider="{beatNames}" width="80" change="onSetBeats()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{beatNames.length}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Beat divisions:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="partDropDown" dataProvider="{partNames}" width="75" change="onSetParts()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{partNames.length}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
			</s:VGroup>
			<s:VGroup id="channelSettings" height="100%" width="100%">
				<s:Label text="Channel Settings:" color="0xffffff"/>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Wave:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="waveDropDown" dataProvider="{waveNames}" width="110" change="onSetWave()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{4}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle" visible="false">
					<s:Label text="Filter Base:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="filterDropDown" dataProvider="{filterNames}" width="75" change="onSetFilter()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{6}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle" visible="false">
					<s:Label text="Filter Decay:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="filterDecayDropDown" dataProvider="{filterDecayNames}" width="75" change="onSetFilterDecay()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{6}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
			</s:VGroup>
			<s:Label text="Beep Box version 1.0" color="0xbbbbbb" right="0"/>
		</s:VGroup>
	</s:HGroup>
</s:BorderContainer>
