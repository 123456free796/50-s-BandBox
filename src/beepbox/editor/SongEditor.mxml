<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright (C) 2012 John Nesky

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
-->

<s:BorderContainer xmlns:fx="http://ns.adobe.com/mxml/2009" 
           xmlns:s="library://ns.adobe.com/flex/spark"
           xmlns="beepbox.editor.*"
           width="700"
           height="645"
           backgroundColor="0x000000"
           borderVisible="false"
           borderWeight="0"
           creationComplete="init()"
           addedToStage="onAddedToStage()">
	<fx:Script><![CDATA[
		import flash.display.*;
		import flash.events.*;
		import flash.geom.*;
		import flash.media.*;
		import flash.text.*;
		import flash.ui.*;
		import flash.utils.*;
		
		import mx.collections.ArrayCollection;
		import mx.controls.Menu;
		import mx.events.MenuEvent;
		
		import beepbox.synth.*;
		
		[Bindable]
		public var doc: Document;
		
		[Bindable]
		private var scaleNames: ArrayCollection;
		[Bindable]
		private var keyNames: ArrayCollection;
		[Bindable]
		private var tempoNames: ArrayCollection;
		[Bindable]
		private var beatNames: ArrayCollection;
		[Bindable]
		private var partNames: ArrayCollection;
		[Bindable]
		private var waveNames: ArrayCollection;
		[Bindable]
		private var filterNames: ArrayCollection;
		[Bindable]
		private var attackNames: ArrayCollection;
		[Bindable]
		private var effectNames: ArrayCollection;
		[Bindable]
		private var chorusNames: ArrayCollection;
		[Bindable]
		private var volumeNames: ArrayCollection;
		
		private var editMenu: Menu;
		private var optionsMenu: Menu;
		private var copyTones: Array;
		private var copyBeats: int = 0;
		private var copyParts: int = 0;
		
		public function init():void {
			scaleNames = new ArrayCollection(Music.scaleNames);
			keyNames = new ArrayCollection(Music.keyNames);
			tempoNames = new ArrayCollection(Music.tempoNames);
			beatNames = new ArrayCollection(Music.beatNames);
			partNames = new ArrayCollection(Music.partNames);
			waveNames = new ArrayCollection(Music.waveNames);
			filterNames = new ArrayCollection(Music.filterNames);
			attackNames = new ArrayCollection(Music.attackNames);
			effectNames = new ArrayCollection(Music.effectNames);
			chorusNames = new ArrayCollection(Music.chorusNames);
			volumeNames = new ArrayCollection(Music.volumeNames);
			doc.watch(onUpdated);
			onUpdated();
			
			editorBox.addEventListener(MouseEvent.MOUSE_DOWN, refocusStage);
		}
		
		private function refocusStage(event: Event): void {
			stage.focus = stage;
		}
		
		private function onUpdated(): void {
			scaleDropDown.selectedIndex = doc.song.scale;
			keyDropDown.selectedIndex = doc.song.key;
			tempoDropDown.selectedIndex = doc.song.tempo;
			beatDropDown.selectedIndex = Music.beatCounts.indexOf(doc.song.beats);
			partDropDown.selectedIndex = Music.partCounts.indexOf(doc.song.parts);
			if (doc.channel == 3) {
				channelSettings.visible = false;
				channelSettingsLabel.visible = false;
			} else {
				channelSettings.visible = true;
				channelSettingsLabel.visible = true;
				waveDropDown.selectedIndex = doc.song.channelWaves[doc.channel];
				filterDropDown.selectedIndex = doc.song.channelFilters[doc.channel];
				attackDropDown.selectedIndex = doc.song.channelAttacks[doc.channel];
				effectDropDown.selectedIndex = doc.song.channelEffects[doc.channel];
				chorusDropDown.selectedIndex = doc.song.channelChorus[doc.channel];
				volumeDropDown.selectedIndex = doc.song.channelVolumes[doc.channel];
			}
			currentState = doc.showLetters ? (doc.showScrollBar ? "showPianoAndScrollBar" : "showPiano") : (doc.showScrollBar ? "showScrollBar" : "hideAll");
			barEditor.width = doc.showLetters ? (doc.showScrollBar ? 460 : 480) : (doc.showScrollBar ? 492 : 512);
		}
		
		private function onAddedToStage(): void {
			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);
			stage.addEventListener(KeyboardEvent.KEY_UP, onKeyReleased);
		}
		
		private function onKeyPressed(event: KeyboardEvent): void {
			//if (event.ctrlKey)
			switch (event.keyCode) {
				case 32: // space
					stage.focus = stage;
					togglePlay();
					break;
				case 90: // z
					if (event.shiftKey) {
						doc.history.redo();
					} else {
						doc.history.undo();
					}
					break;
				case 89: // y
					doc.history.redo();
					break;
				case 67: // c
					copy();
					break;
				case 86: // v
					paste();
					break;
				case 219: // left brace
					doc.synth.prevBar();
					break;
				case 221: // right brace
					doc.synth.nextBar();
					break;
			}
		}
		
		private function onKeyReleased(event: KeyboardEvent): void {
		}
		
		private function togglePlay(): void {
			if (doc.synth.playing) {
				doc.synth.pause();
				doc.synth.snapToBar();
				playButton.label = "Resume Playback";
			} else {
				doc.synth.play();
				playButton.label = "Pause Playback";
			}
		}
		
		private function copy(): void {
			copyTones = doc.song.getBarPattern(doc.channel, doc.bar).cloneTones();
			copyBeats = doc.song.beats;
			copyParts = doc.song.parts;
		}
		
		private function paste(): void {
			if (!canPaste()) return;
			doc.history.record(new ChangePaste(doc, copyTones));
		}
		
		private function cleanSlate(): void {
			doc.history.record(new ChangeSong(doc, null));
		}
		
		private function export(): void {
			var wasPlaying: Boolean = doc.synth.playing;
			if (wasPlaying) togglePlay();
			
			var sampleFrames: int = doc.synth.totalSamples;
			var recordedSamples: ByteArray = new ByteArray();
			var timer: int = getTimer();
			new Synth(doc.song).synthesize(recordedSamples, sampleFrames, false);
			trace("export timer", getTimer() - timer);
			
			var srcChannelCount: int = 2;
			var wavChannelCount: int = 1;
			var sampleRate: int = 44100;
			var bytesPerSample: int = 2;
			var bitsPerSample: int = 8 * bytesPerSample;
			var sampleCount: int = wavChannelCount * sampleFrames;

			var data: ByteArray = new ByteArray();
			data.endian = Endian.LITTLE_ENDIAN;
			data.writeUTFBytes("RIFF");
			data.writeInt(36 + sampleCount * bytesPerSample); // size of remaining file
			data.writeUTFBytes("WAVEfmt ");
			data.writeInt(0x00000010); // size of following header
			data.writeShort(0x0001); // not compressed
			data.writeShort(wavChannelCount); // channel count
			data.writeInt(sampleRate); // sample rate
			data.writeInt(sampleRate * bytesPerSample * wavChannelCount); // bytes per second
			data.writeShort(bytesPerSample); // sample rate
			data.writeShort(bitsPerSample); // sample rate
			data.writeUTFBytes("data");
			data.writeInt(sampleCount * bytesPerSample);
			
			var stride: int;
			var repeat: int;
			if (srcChannelCount == wavChannelCount) {
				stride = 1;
				repeat = 1;
			} else {
				stride = srcChannelCount;
				repeat = wavChannelCount;
			}
			
			var i: int;
			var j: int;
			var k: int;
			var val: int;
			recordedSamples.position = 0;
			if (bytesPerSample > 1) {
				// usually samples are signed. 
				for (i = 0; i < sampleFrames; i++) {
					for (j = 0; j < stride; j++) {
						val = recordedSamples.readFloat() * ((1 << (bitsPerSample - 1)) - 1);
					}
					for (k = 0; k < repeat; k++) {
						if (bytesPerSample == 2) {
							data.writeShort(val);
						} else if (bytesPerSample == 4) {
							data.writeInt(val);
						} else {
							throw new Error("unsupported sample size");
						}
					}
				}
			} else {
				// 8 bit samples are a special case: they are unsigned.
				for (i = 0; i < sampleFrames; i++) {
					for (j = 0; j < stride; j++) {
						val = recordedSamples.readFloat() * 127 + 128;
					}
					for (k = 0; k < repeat; k++) {
						data.writeByte(val > 255 ? 255 : (val < 0 ? 0 : val));
					}
				}
			}
			
			new FileReference().save(data, "song.wav");
			
			if (wasPlaying) togglePlay();
		}
		
		private function onSetScale(): void {
			var scale: int = scaleDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeScale) doc.history.undo();
			doc.history.record(new ChangeScale(doc, scale));
		}
		
		private function onSetKey(): void {
			var key: int = keyDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeKey) doc.history.undo();
			doc.history.record(new ChangeKey(doc, key));
		}
		
		private function onSetTempo(): void {
			var tempo: int = tempoDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeTempo) doc.history.undo();
			doc.history.record(new ChangeTempo(doc, tempo));
		}
		
		private function onSetBeats(): void {
			var beats: int = Music.beatCounts[beatDropDown.selectedIndex];
			//if (doc.history.getRecentChange() is ChangeBeats) doc.history.undo();
			doc.history.record(new ChangeBeats(doc, beats));
		}
		
		private function onSetParts(): void {
			var parts: int = Music.partCounts[partDropDown.selectedIndex];
			//if (doc.history.getRecentChange() is ChangeParts) doc.history.undo();
			doc.history.record(new ChangeParts(doc, parts));
		}
		
		private function onSetWave(): void {
			var wave: int = waveDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeWave) doc.history.undo();
			doc.history.record(new ChangeWave(doc, wave));
		}
		
		private function onSetFilter(): void {
			var filter: int = filterDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeFilter) doc.history.undo();
			doc.history.record(new ChangeFilter(doc, filter));
		}
		
		private function onSetAttack(): void {
			var attack: int = attackDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeAttack) doc.history.undo();
			doc.history.record(new ChangeAttack(doc, attack));
		}
		
		private function onSetEffect(): void {
			var effect: int = effectDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeEffect) doc.history.undo();
			doc.history.record(new ChangeEffect(doc, effect));
		}
		
		private function onSetChorus(): void {
			var chorus: int = chorusDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeChorus) doc.history.undo();
			doc.history.record(new ChangeChorus(doc, chorus));
		}
		
		private function onSetVolume(): void {
			var volume: int = volumeDropDown.selectedIndex;
			//if (doc.history.getRecentChange() is ChangeVolume) doc.history.undo();
			doc.history.record(new ChangeVolume(doc, volume));
		}
		
		private function canPaste(): Boolean {
			return copyTones != null && copyBeats == doc.song.beats && copyParts == doc.song.parts;
		}
		
		private function openEditMenu(): void {
			var editNameSpace: Namespace =  new Namespace("beepbox.editor.*");
			editMenuData.editNameSpace::menuitem.(@eventName == "undo")[0].@enabled = doc.history.canUndo();
			editMenuData.editNameSpace::menuitem.(@eventName == "redo")[0].@enabled = doc.history.canRedo();
			editMenuData.editNameSpace::menuitem.(@eventName == "paste")[0].@enabled = canPaste();
			
			editMenu = Menu.createMenu(this, editMenuData, false);
			editMenu.labelField = "@label";
			editMenu.addEventListener(MenuEvent.ITEM_CLICK, editMenuHandler);
		
			var point1:Point = new Point();
			point1 = editButton.localToGlobal(point1);
		
			editMenu.show(point1.x, point1.y + 20);
		}
		
		private function editMenuHandler(event:MenuEvent):void  {
			switch (String(event.item.@eventName)) {
				case "undo":
					doc.history.undo();
					break;
				case "redo":
					doc.history.redo();
					break;
				case "copy":
					copy();
					break;
				case "paste":
					paste();
					break;
				case "export":
					export();
					break;
				case "clean":
					cleanSlate();
					break;
			}
		}
		
		private function openOptionsMenu(): void {
			var optionsNameSpace: Namespace =  new Namespace("beepbox.editor.*");
			optionsMenuData.optionsNameSpace::menuitem.(@eventName == "showLetters")[0].@toggled = doc.showLetters;
			optionsMenuData.optionsNameSpace::menuitem.(@eventName == "showFifth")[0].@toggled = doc.showFifth;
			optionsMenuData.optionsNameSpace::menuitem.(@eventName == "showChannels")[0].@toggled = doc.showChannels;
			optionsMenuData.optionsNameSpace::menuitem.(@eventName == "showScrollBar")[0].@toggled = doc.showScrollBar;
			
			optionsMenu = Menu.createMenu(this, optionsMenuData, false);
			optionsMenu.labelField = "@label";
			optionsMenu.addEventListener(MenuEvent.ITEM_CLICK, optionsMenuHandler);
		
			var point1:Point = new Point();
			point1 = optionsButton.localToGlobal(point1);
		
			optionsMenu.show(point1.x, point1.y + 20);
		}
		
		private function optionsMenuHandler(event:MenuEvent):void  {
			switch (String(event.item.@eventName)) {
				case "showLetters":
					doc.showLetters = !doc.showLetters;
					break;
				case "showFifth":
					doc.showFifth = !doc.showFifth;
					break;
				case "showChannels":
					doc.showChannels = !doc.showChannels;
					break;
				case "showScrollBar":
					doc.showScrollBar = !doc.showScrollBar;
					break;
			}
			doc.changed();
			doc.savePreferences();
		}
	]]></fx:Script>
	
	<s:states>
		<s:State name="hideAll"/>
		<s:State name="showPiano"/>
		<s:State name="showScrollBar"/>
		<s:State name="showPianoAndScrollBar"/>
	</s:states>
	
	<s:HGroup width="100%" height="100%">
		<s:VGroup width="512" id="editorBox">
			<s:HGroup width="512" height="481" gap="0">
				<Piano id="piano" doc="{doc}" includeIn="showPiano, showPianoAndScrollBar"/>
				<BarEditor id="barEditor" doc="{doc}"/>
				<OctaveScrollBar id="octaveScrollBar" doc="{doc}" includeIn="showScrollBar, showPianoAndScrollBar"/>
			</s:HGroup>
			<TrackEditor doc="{doc}"/>
			<LoopEditor doc="{doc}"/>
		</s:VGroup>
		<s:VGroup width="100%" height="100%">
			<s:VGroup id="songSettings" height="481" width="100%">
				<s:HGroup width="100%" verticalAlign="middle">
					<s:Spacer width="50%"/>
					<s:Label text="Beep Box version 1.0.1" color="0xbbbbbb" right="0"/>
					<s:Spacer width="50%"/>
				</s:HGroup>
				<s:Button id="playButton" label="Pause Playback" click="togglePlay(); stage.focus = stage" width="100%"/>
				<s:Button id="editButton" label="Edit" click="openEditMenu();" width="100%"/>
				<s:Button id="optionsButton" label="Options" click="openOptionsMenu();" width="100%"/>
				<s:Spacer height="5"/>
				<s:Label text="Song Settings:" color="0xffffff"/>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Scale:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="scaleDropDown" dataProvider="{scaleNames}" width="90" change="onSetScale()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{scaleNames.length}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Key:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="keyDropDown" dataProvider="{keyNames}" width="90" change="onSetKey()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{keyNames.length}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Tempo:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="tempoDropDown" dataProvider="{tempoNames}" width="90" change="onSetTempo()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{tempoNames.length}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Beats per bar:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="beatDropDown" dataProvider="{beatNames}" width="90" change="onSetBeats()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{beatNames.length}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Beat divisions:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="partDropDown" dataProvider="{partNames}" width="90" change="onSetParts()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{partNames.length}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:Spacer height="100%"/>
				<s:Label id="channelSettingsLabel" text="Channel Settings:" color="0xffffff"/>
			</s:VGroup>
			<s:VGroup id="channelSettings" height="100%" width="100%">
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Volume:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="volumeDropDown" dataProvider="{volumeNames}" width="120" change="onSetVolume()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{4}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Wave:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="waveDropDown" dataProvider="{waveNames}" width="120" change="onSetWave()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{4}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Envelope:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="attackDropDown" dataProvider="{attackNames}" width="120" change="onSetAttack()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{4}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Filter:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="filterDropDown" dataProvider="{filterNames}" width="120" change="onSetFilter()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{4}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Chorus:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="chorusDropDown" dataProvider="{chorusNames}" width="120" change="onSetChorus()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{4}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
				<s:HGroup width="100%" gap="0" verticalAlign="middle">
					<s:Label text="Effect:" color="0xbbbbbb"/>
					<s:Spacer width="100%"/>
					<s:DropDownList id="effectDropDown" dataProvider="{effectNames}" width="120" change="onSetEffect()" close="stage.focus = stage" right="0">
						<s:layout> <s:VerticalLayout requestedRowCount="{4}" horizontalAlign="justify"/> </s:layout>
					</s:DropDownList>
				</s:HGroup>
			</s:VGroup>
		</s:VGroup>
	</s:HGroup>

	<fx:Declarations>
		<fx:XML id="editMenuData">
			<root>
				<menuitem label="Undo (Z)" eventName="undo"/>
				<menuitem label="Redo (Y)" eventName="redo"/>
				<menuitem label="Copy Pattern (C)" eventName="copy"/>
				<menuitem label="Paste Pattern (V)" eventName="paste"/>
				<menuitem label="Export to .wav File" eventName="export"/>
				<menuitem label="Clean Slate" eventName="clean"/>
			</root>
		</fx:XML>
		<fx:XML id="optionsMenuData">
			<root>
				<menuitem type="check" label="Show Piano" eventName="showLetters"/>
				<menuitem type="check" label="Highlight 'Fifth' Notes" eventName="showFifth"/>
				<menuitem type="check" label="Show All Channels" eventName="showChannels"/>
				<menuitem type="check" label="Show Scroll Bar" eventName="showScrollBar"/>
			</root>
		</fx:XML>
	</fx:Declarations>
</s:BorderContainer>
